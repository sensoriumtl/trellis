//! Inner type for handling of data writing, storage and cleanup
use fs_err::{File, OpenOptions};
use serde::Serialize;
use std::io::BufWriter;
use std::path::PathBuf;
use tempfile::{Builder, TempDir};

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum WriteToFileSerializer {
    /// Use [`bincode`](https://crates.io/crates/bincode) for creating binary files
    Bincode,
    /// Use [`serde_json`](https://crates.io/crates/serde_json) for creating JSON files
    JSON,
}

impl Default for WriteToFileSerializer {
    fn default() -> Self {
        Self::Bincode
    }
}

#[derive(Debug, thiserror::Error)]
pub enum WriterError {
    #[error("Error in serde bincode {0}")]
    Bincode(#[from] Box<bincode::ErrorKind>),
    #[error("Error in IO Operation {0}")]
    IO(#[from] std::io::Error),
    #[error("Error in serde json {0}")]
    SerdeJson(#[from] serde_json::Error),
    #[error("Error in csv {0}")]
    Csv(#[from] csv::Error),
}

#[derive(Debug)]
pub struct Writer {
    /// Root directory for the stored output
    directory: PathBuf,
    /// Identifier for the data written
    identifier: String,
    /// temporary directory path
    tmp_dir: Option<TempDir>,
    /// Whether to preserve_history intermediate results after an iteration completes
    preserve_history: bool,
    /// Path to the latest written file
    last_modified: Option<PathBuf>,
    /// Name override
    ///
    /// Sometimes we do not want to write using the identifier of the writeable, for example if the
    /// data is generated by an inner iterative scheme we might not care about the number of inner
    /// iterations, only the number of outer ones. The writeable cannot know this number, so we
    /// store an alternative here.
    ///
    /// This field, if it exists, will override the identifier of any writeable written with the
    /// writer. It only makes sense to use this when the Writer is expected to be called once
    writeable_identifier: Option<String>,
}

pub trait Writeable {
    type Data: Serialize;

    fn identifier(&self) -> &str;
    fn data(&self) -> &Self::Data;
}

#[derive(Serialize)]
struct Measure<F: Serialize> {
    iteration: usize,
    measure: F,
}

impl Writer {
    // Create a new writer, below `directory`
    pub(crate) fn new<P: Into<PathBuf>>(
        directory: P,
        identifier: String,
    ) -> Result<Self, WriterError> {
        let directory: PathBuf = directory.into();

        // If the requested output directory does not exist, create it
        if !directory.exists() {
            std::fs::create_dir_all(&directory)?;
        }

        let tmp_dir = Builder::new().prefix(&identifier).tempdir_in(&directory)?;

        Ok(Self {
            tmp_dir: Some(tmp_dir),
            identifier,
            directory,
            preserve_history: true,
            last_modified: None,
            writeable_identifier: None,
        })
    }

    #[must_use]
    pub(crate) fn with_writeable_identifier(mut self, identifier: String) -> Self {
        self.writeable_identifier = Some(identifier);
        self
    }

    // Write data to `tmp_dir`
    pub(crate) fn write<W>(
        &mut self,
        serializer: WriteToFileSerializer,
        writeable: &W,
    ) -> Result<(), WriterError>
    where
        W: Writeable,
    {
        if let Some(tmp_dir) = self.tmp_dir.as_ref() {
            let fname = tmp_dir.path().join(format!(
                "{}.arp",
                self.writeable_identifier
                    .as_ref()
                    .map_or_else(|| writeable.identifier(), |identifier| identifier)
            ));
            let f = BufWriter::new(File::create(fname.clone())?);

            match serializer {
                WriteToFileSerializer::Bincode => {
                    bincode::serialize_into(f, writeable.data())?;
                }
                WriteToFileSerializer::JSON => {
                    serde_json::to_writer_pretty(f, writeable.data())?;
                }
            }

            // Update the last modified file
            let _ = self.last_modified.replace(fname);

            return Ok(());
        }
        panic!("tmp_dir not found");
    }

    // Write data to `tmp_dir`
    pub(crate) fn write_pair<F: Serialize>(
        &mut self,
        iteration: usize,
        measure: F,
    ) -> Result<(), WriterError> {
        if let Some(tmp_dir) = self.tmp_dir.as_ref() {
            let fname = tmp_dir.path().join("measure.arp");

            let file = BufWriter::new(
                OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(fname.clone())?,
            );

            let data = Measure { iteration, measure };

            // If the file is not empty do not re-write the headers
            let mut wtr = if fs_err::metadata(&fname)?.len() > 0 {
                csv::WriterBuilder::new()
                    .has_headers(false)
                    .from_writer(file)
            } else {
                csv::Writer::from_writer(file)
            };

            wtr.serialize(data)?;

            // Update the last modified file
            let _ = self.last_modified.replace(fname);

            return Ok(());
        }
        panic!("tmp_dir not found");
    }
    // Cleanup intermediate results from previous iterations
    //
    // After an iteration we get the converged result and move it to `directory`
    // Where this could be is currently not clear to me. What is a good pattern?
    fn cleanup(&mut self) -> Result<(), WriterError> {
        // Move latest file to top level directory
        if let Some(last_modified) = self.last_modified.as_ref() {
            let mut new_location = self.directory.clone();
            new_location.push(format!("{}.arp", self.identifier));
            fs_err::copy(last_modified, new_location)?;
        }

        if self.preserve_history {
            if let Some(tmp_dir) = self.tmp_dir.as_ref() {
                // Delete sub directory
                let mut perm_dir = self.directory.clone();
                perm_dir.push(&self.identifier);
                if !perm_dir.exists() {
                    fs_err::create_dir(&perm_dir)?;
                }

                for entry in fs_err::read_dir(tmp_dir.path())? {
                    let location = entry?.path();
                    let mut new_location = perm_dir.clone();

                    if let Some(file_name) = location.file_name() {
                        new_location.push(file_name);
                        fs_err::copy(location, new_location)?;
                    }
                }
            }
        }

        if let Some(tmp_dir) = self.tmp_dir.take() {
            tmp_dir.close()?;
        }

        // If this is the last `Writer` pointing to `Directory` then remove that too
        if self.directory.read_dir()?.next().is_none() {
            fs_err::remove_dir_all(&self.directory)?;
        }

        Ok(())
    }
}

impl Drop for Writer {
    fn drop(&mut self) {
        let _ = self.cleanup();
    }
}
